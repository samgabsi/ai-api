import Foundation

/// Represents an image uploaded by the user to be made available to the bash command.
public struct BashImageUpload {
    /// Suggested filename (extension optional). Used when saving the image to disk.
    public let filename: String
    /// Raw image data.
    public let data: Data
    /// Optional MIME type (e.g., "image/png"). Helps determine the file extension if missing.
    public let mimeType: String?
}

/// Represents an uploaded image that was written to disk and exposed to the command.
public struct BashImageAttachment {
    /// Final filename on disk (sanitized).
    public let filename: String
    /// Absolute file URL of the saved image inside the working directory.
    public let fileURL: URL
    /// Optional MIME type if known.
    public let mimeType: String?
    /// The environment variable name that points to this file path (e.g., IMAGE_1).
    public let environmentVariable: String
}

/// Represents an image generated by the command that can be presented/downloaded by the UI.
public struct BashGeneratedImage {
    /// Final filename on disk.
    public let filename: String
    /// Absolute file URL of the generated image inside the working directory.
    public let fileURL: URL
    /// Best-effort MIME type based on file extension.
    public let mimeType: String
    /// File size in bytes, if known.
    public let bytes: Int
}

/// Represents any file generated by the command that the UI can present for preview/download.
public struct BashGeneratedFile {
    /// Final filename on disk.
    public let filename: String
    /// Absolute file URL of the generated file inside the working directory.
    public let fileURL: URL
    /// Best-effort MIME type based on file extension.
    public let mimeType: String
    /// File size in bytes, if known.
    public let bytes: Int
}

/// A structure representing the result of executing a Bash query.
public struct BashQueryResult {
    /// The original query string requested.
    public let requested: String
    /// The actual Bash command executed.
    public let executedCommand: String
    /// The collected standard output from the command.
    public let stdout: String
    /// The collected standard error output from the command.
    public let stderr: String
    /// The exit code returned by the command.
    public let exitCode: Int32
    /// A list of tools that were installed during execution.
    public let installedTools: [String]
    /// The working directory used for this execution. Uploaded and generated files live here.
    public let workingDirectory: URL
    /// Images uploaded by the caller and made available to the command via environment variables.
    public let uploadedImages: [BashImageAttachment]
    /// Images generated by the command that the UI can present for preview/download.
    public let outputImages: [BashGeneratedImage]
    /// All files generated by the command (images and non-images).
    public let outputFiles: [BashGeneratedFile]
}

/// An executor for running queries starting with "bash:" using BashRunner.
/// 
/// This executor parses the input command, attempts to ensure the primary tool is installed (using Homebrew on macOS if needed),
/// runs the command, and collects output asynchronously.
/// 
/// - Note: Timeouts are applied to installation and execution phases to avoid indefinite hangs.
/// - Note: This executor assumes a POSIX-like environment with Bash and the availability of `command -v`.
public enum BashQueryExecutor {
    
    /// Returns whether the input string can be handled by this executor.
    /// - Parameter input: The input query string.
    /// - Returns: True if the input starts with "bash:" (case-insensitive, trimmed).
    public static func canHandle(_ input: String) -> Bool {
        input.trimmingCharacters(in: .whitespacesAndNewlines).lowercased().hasPrefix("bash:")
    }
    
    public static func execute(_ input: String, timeout: TimeInterval = 120, inputImages: [BashImageUpload] = []) async -> BashQueryResult {
        let requested = input
        
        // Create a unique working directory for this execution
        let fm = FileManager.default
        let workingDirectory: URL = fm.temporaryDirectory.appendingPathComponent("BashQuery-\(UUID().uuidString)", isDirectory: true)
        do {
            try fm.createDirectory(at: workingDirectory, withIntermediateDirectories: true)
        } catch {
            // If we fail to create the working directory, we still proceed but note the error later in stderr
        }
        
        // Extract command substring after the first colon
        let commandPart = input.drop { $0 != ":" }.dropFirst().trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Persist uploaded images (if any) into the working directory and prepare env exports
        var uploadedImageAttachments: [BashImageAttachment] = []
        var envExports: [(String, String)] = [] // (VAR, value)

        func sanitizeFilename(_ name: String, fallback: String) -> String {
            let invalid = CharacterSet(charactersIn: "/\\:\"|?*<>\n\r")
            var base = name.trimmingCharacters(in: .whitespacesAndNewlines)
            if base.isEmpty { base = fallback }
            base = base.components(separatedBy: invalid).joined(separator: "_")
            return base
        }

        func extForMime(_ mime: String) -> String? {
            switch mime.lowercased() {
            case "image/png": return "png"
            case "image/jpeg": return "jpg"
            case "image/jpg": return "jpg"
            case "image/gif": return "gif"
            case "image/webp": return "webp"
            case "image/bmp": return "bmp"
            case "image/tiff": return "tiff"
            case "image/heic": return "heic"
            case "image/heif": return "heif"
            case "image/svg+xml": return "svg"
            default: return nil
            }
        }

        for (idx, upload) in inputImages.enumerated() {
            var fname = upload.filename
            if URL(fileURLWithPath: fname).pathExtension.isEmpty, let mt = upload.mimeType, let ext = extForMime(mt) {
                fname += ".\(ext)"
            }
            let safeName = sanitizeFilename(fname, fallback: "image\(idx+1).bin")
            let fileURL = workingDirectory.appendingPathComponent(safeName)
            do { try upload.data.write(to: fileURL) } catch { /* If writing fails, continue and let bash stderr surface errors */ }
            let env = "IMAGE_\(idx+1)"
            uploadedImageAttachments.append(BashImageAttachment(filename: safeName, fileURL: fileURL, mimeType: upload.mimeType, environmentVariable: env))
            envExports.append((env, fileURL.path))
        }
        envExports.append(("IMAGE_COUNT", String(uploadedImageAttachments.count)))
        envExports.append(("IMAGE_DIR", workingDirectory.path))
        envExports.append(("BASH_WORK_DIR", workingDirectory.path))
        
        // Backwards-compatible: also expose generic FILE_* variables
        for (idx, att) in uploadedImageAttachments.enumerated() {
            envExports.append(("FILE_\(idx+1)", att.fileURL.path))
        }
        envExports.append(("FILE_COUNT", String(uploadedImageAttachments.count)))
        envExports.append(("FILE_DIR", workingDirectory.path))
        
        func shellEscape(_ s: String) -> String {
            // Wrap in single quotes and escape any existing single quotes
            return "'" + s.replacingOccurrences(of: "'", with: "'\"'\"'") + "'"
        }
        
        // Map common network intents to concrete commands/tools
        func mapNetworkIntent(_ s: String) -> (cmd: String, tool: String)? {
            let l = s.trimmingCharacters(in: .whitespacesAndNewlines)
            let lowered = l.lowercased()

            func firstMatch(_ pattern: String) -> String? {
                guard let re = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]) else { return nil }
                let range = NSRange(location: 0, length: l.utf16.count)
                if let m = re.firstMatch(in: l, options: [], range: range), m.numberOfRanges >= 2,
                   let r = Range(m.range(at: 1), in: l) {
                    let token = String(l[r]).trimmingCharacters(in: .whitespacesAndNewlines)
                    return token.isEmpty ? nil : token
                }
                return nil
            }

            // Extract host candidates (IPv4 or hostname) from general text
            func extractHost(_ text: String) -> String? {
                if let re = try? NSRegularExpression(pattern: #"\b\d{1,3}(?:\.\d{1,3}){3}\b"#, options: []),
                   let m = re.firstMatch(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count)),
                   let r = Range(m.range, in: text) { return String(text[r]) }
                if let re2 = try? NSRegularExpression(pattern: #"\b(?:to|on|for|against|of|for host|host)\s+([A-Za-z0-9_.\-]+)\b"#, options: [.caseInsensitive]),
                   let m2 = re2.firstMatch(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count)),
                   m2.numberOfRanges >= 2,
                   let r2 = Range(m2.range(at: 1), in: text) { return String(text[r2]) }
                // Fallback: first bare hostname-like token
                if let re3 = try? NSRegularExpression(pattern: #"\b([A-Za-z0-9][A-Za-z0-9_.\-]{1,})\b"#, options: []),
                   let m3 = re3.firstMatch(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count)),
                   let r3 = Range(m3.range(at: 1), in: text) { return String(text[r3]) }
                return nil
            }

            // 1) Nmap: port scan / services
            if lowered.contains("port scan") || lowered.contains("scan ports") || (lowered.contains("scan") && (lowered.contains("services") || lowered.contains("ports"))) || lowered.contains("what ports") || lowered.contains("services are exposed") {
                if let host = extractHost(l) { return ("nmap -sV -Pn \(host)", "nmap") }
            }

            // 2) Ping / latency
            if lowered.hasPrefix("ping") || lowered.contains("latency") || lowered.contains("round trip") {
                if let host = firstMatch(#"ping\s+([^\s]+)"#) ?? extractHost(l) { return ("ping -c 5 \(host)", "ping") }
            }

            // 3) Traceroute
            if lowered.contains("traceroute") || lowered.contains("trace route") || lowered.contains("route to") || lowered.contains("path to") {
                if let host = firstMatch(#"traceroute\s+([^\s]+)"#) ?? extractHost(l) { return ("traceroute \(host)", "traceroute") }
            }

            // 4) DNS: dig / nslookup / resolve
            if lowered.contains("dig ") || lowered.contains("nslookup") || lowered.contains("dns") || lowered.contains("resolve") || lowered.contains("lookup") {
                if let host = firstMatch(#"(?:dig|nslookup|dns|resolve|lookup)\s+([^\s]+)"#) ?? extractHost(l) {
                    // Prefer dig if available; we'll set tool to dig but command will work regardless
                    return ("dig +short \(host)", "dig")
                }
            }

            // 5) WHOIS
            if lowered.contains("whois") || lowered.contains("domain info") || lowered.contains("registrar") {
                if let domain = firstMatch(#"(?:whois|domain\s+info\s+for)\s+([^\s]+)"#) ?? extractHost(l) { return ("whois \(domain)", "whois") }
            }

            // 6) HTTP headers / fetch
            if lowered.contains("http headers") || lowered.contains("headers for") || lowered.hasPrefix("curl") || lowered.contains("fetch url") || lowered.contains("check url") {
                if let url = firstMatch(#"(?:curl|http\s+headers\s+for|headers\s+for|fetch\s+url|check\s+url)\s+([^\s]+)"#) ?? extractHost(l) { return ("curl -I \(url)", "curl") }
            }

            // 7) Local IP / interfaces
            if lowered.contains("my ip") || lowered.contains("show ip") || lowered.contains("show interfaces") || lowered.contains("interfaces") || lowered.contains("ifconfig") {
                // macOS-friendly
                return ("ifconfig", "ifconfig")
            }

            // 8) Open/listening connections
            if lowered.contains("open connections") || lowered.contains("listening ports") || lowered.contains("list open ports") || lowered.contains("netstat") || lowered.contains("listening sockets") {
                // macOS-safe listing
                return ("lsof -i -P -n | grep LISTEN || netstat -an | grep LISTEN", "lsof")
            }

            // 9) Nmap variants: all ports / UDP
            if (lowered.contains("scan all ports") || lowered.contains("all ports")), let host = extractHost(l) {
                return ("nmap -sV -Pn -p- \(host)", "nmap")
            }
            if lowered.contains("udp scan"), let host = extractHost(l) {
                return ("nmap -sU -sV -Pn \(host)", "nmap")
            }

            // 10) Reverse DNS / PTR
            if lowered.contains("reverse dns") || lowered.contains("ptr") || lowered.contains("reverse lookup") {
                if let ip = firstMatch(#"(?:reverse\s+dns|ptr|reverse\s+lookup)\s+([0-9\.]+)"#) ?? extractHost(l) {
                    return ("dig +short -x \(ip)", "dig")
                }
            }

            // 11) DNS record types (MX/TXT/NS/A/AAAA/CNAME)
            if let re = try? NSRegularExpression(pattern: #"\b(mx|txt|ns|a|aaaa|cname)\b\s+(?:for\s+)?([^\s]+)"#, options: [.caseInsensitive]) {
                let range = NSRange(location: 0, length: l.utf16.count)
                if let m = re.firstMatch(in: l, options: [], range: range), m.numberOfRanges >= 3,
                   let r1 = Range(m.range(at: 1), in: l), let r2 = Range(m.range(at: 2), in: l) {
                    let t = String(l[r1]).uppercased()
                    let host = String(l[r2])
                    return ("dig +short \(t) \(host)", "dig")
                }
            }

            // 12) TLS/SSL details
            if lowered.contains("tls details") || lowered.contains("ssl cert") || lowered.contains("certificate details") || lowered.contains("check tls") {
                if let host = extractHost(l) {
                    return ("openssl s_client -connect \(host):443 -servername \(host) -showcerts </dev/null", "openssl")
                }
            }

            // 13) HTTP timing / measure
            if lowered.contains("measure http") || lowered.contains("timing for") || lowered.contains("response time for") {
                if let url = extractHost(l) ?? firstMatch(#"(?:http|https)://[^\s]+"#) {
                    return ("curl -o /dev/null -s -w 'time_connect:%{time_connect} time_starttransfer:%{time_starttransfer} time_total:%{time_total}\n' \(url)", "curl")
                }
            }

            // 14) iperf3 throughput test (client)
            if lowered.contains("iperf3") || lowered.contains("bandwidth test") || lowered.contains("throughput test") {
                if let host = firstMatch(#"iperf3\s+-?c?\s*([^\s]+)"#) ?? extractHost(l) {
                    return ("iperf3 -c \(host) -t 10", "iperf3")
                }
            }

            // 15) MTR path quality
            if lowered.contains("mtr") || lowered.contains("path quality") || lowered.contains("loss to") || lowered.contains("jitter to") {
                if let host = firstMatch(#"mtr\s+([^\s]+)"#) ?? extractHost(l) {
                    return ("mtr -wzc 100 \(host)", "mtr")
                }
            }

            // 16) ARP / neighbors
            if lowered.contains("arp table") || lowered.contains("neighbors") || lowered.contains("neighbor table") || lowered.contains("arp -a") {
                return ("arp -a", "arp")
            }

            // 17) Netcat port check
            if lowered.contains("check port") || lowered.contains("test tcp") || lowered.contains("nc -vz") || lowered.contains("netcat") {
                if let re = try? NSRegularExpression(pattern: #"(?:check\s+port|test\s+tcp)\s+(\d{1,5})\s+(?:on|against|to)\s+([^\s]+)"#, options: [.caseInsensitive]) {
                    let range = NSRange(location: 0, length: l.utf16.count)
                    if let m = re.firstMatch(in: l, options: [], range: range), m.numberOfRanges >= 3,
                       let rPort = Range(m.range(at: 1), in: l), let rHost = Range(m.range(at: 2), in: l) {
                        let port = String(l[rPort])
                        let host = String(l[rHost])
                        return ("nc -vz \(host) \(port)", "nc")
                    }
                }
                if let host = extractHost(l) { return ("nc -vz \(host) 80", "nc") }
            }

            // 18) SSH banner/version
            if lowered.contains("ssh banner") || lowered.contains("ssh version") || lowered.contains("ssh service") {
                if let host = extractHost(l) { return ("nc -vz \(host) 22 || nmap -sV -p22 \(host)", "nc") }
            }

            // 19) Service banner on port
            if lowered.contains("grab banner") || lowered.contains("service banner") {
                if let re = try? NSRegularExpression(pattern: #"(?:on|port)\s+(\d{1,5})\b.*?\b(?:host|on|to)?\s*([^\s]+)"#, options: [.caseInsensitive]) {
                    let range = NSRange(location: 0, length: l.utf16.count)
                    if let m = re.firstMatch(in: l, options: [], range: range), m.numberOfRanges >= 3,
                       let rPort = Range(m.range(at: 1), in: l), let rHost = Range(m.range(at: 2), in: l) {
                        let port = String(l[rPort])
                        let host = String(l[rHost])
                        return ("(echo; sleep 1) | nc \(host) \(port)", "nc")
                    }
                }
            }

            // 20) Default route / gateway / routing table
            if lowered.contains("default route") || lowered.contains("default gateway") || lowered.contains("gateway") || lowered.contains("routing table") || lowered.contains("route table") {
                return ("route -n get default 2>/dev/null || netstat -rn", "route")
            }

            // 21) Public IP / external IP
            if lowered.contains("public ip") || lowered.contains("external ip") || lowered.contains("wan ip") || lowered.contains("my ip public") {
                return ("curl -s https://ifconfig.me || curl -s https://api.ipify.org", "curl")
            }

            // 22) DNS configuration (macOS)
            if lowered.contains("dns config") || lowered.contains("show dns") || lowered.contains("resolver config") {
                return ("scutil --dns", "scutil")
            }

            // 23) Network services info (macOS)
            if lowered.contains("network info") || lowered.contains("interface details") || lowered.contains("hardware ports") || lowered.contains("list interfaces") {
                return ("networksetup -listallhardwareports; echo; ifconfig", "networksetup")
            }

            // 24) HTTP GET / download with size
            if lowered.contains("download url") || lowered.contains("http get") || lowered.contains("fetch http") {
                if let url = firstMatch(#"(?:download\s+url|http\s+get|fetch\s+http)\s+([^\s]+)"#) ?? extractHost(l) {
                    return ("curl -L -s -D - \(url) | tee /dev/null | wc -c", "curl")
                }
            }

            // 25) TLS certificate expiry
            if lowered.contains("cert expiry") || lowered.contains("certificate expiry") || lowered.contains("expiry for") {
                if let host = extractHost(l) {
                    return ("echo | openssl s_client -connect \(host):443 -servername \(host) 2>/dev/null | openssl x509 -noout -dates", "openssl")
                }
            }

            // 26) Email ports tests (SMTP/Submission/IMAPS/POP3S)
            if lowered.contains("test smtp") || lowered.contains("test imap") || lowered.contains("test pop") || lowered.contains("email port") {
                if let re = try? NSRegularExpression(pattern: #"test\s+(smtp|imap|pop)\s+([^\s]+)"#, options: [.caseInsensitive]) {
                    let range = NSRange(location: 0, length: l.utf16.count)
                    if let m = re.firstMatch(in: l, options: [], range: range), m.numberOfRanges >= 3,
                       let rSvc = Range(m.range(at: 1), in: l), let rHost = Range(m.range(at: 2), in: l) {
                        let svc = String(l[rSvc]).lowercased()
                        let host = String(l[rHost])
                        let port: String = (svc == "smtp") ? "25" : (svc == "imap" ? "993" : "995")
                        return ("nc -vz \(host) \(port)", "nc")
                    }
                }
            }

            // 27) SMB shares (macOS)
            if lowered.contains("smb shares") || lowered.contains("list smb") || lowered.contains("samba shares") {
                if let host = extractHost(l) { return ("smbutil view //guest@\(host)", "smbutil") }
            }

            // 28) DHCP info (macOS, default interface en0)
            if lowered.contains("dhcp info") || lowered.contains("dhcp lease") || lowered.contains("dhcp details") {
                return ("ipconfig getpacket en0", "ipconfig")
            }

            // 56) Packet capture summary (tcpdump, macOS default en0)
            if lowered.contains("packet capture") || lowered.contains("tcpdump") || lowered.contains("pcap summary") {
                if let iface = firstMatch(#"interface\s+([^\s]+)"#) { return ("tcpdump -c 50 -n -i \(iface)", "tcpdump") }
                return ("tcpdump -c 50 -n -i en0", "tcpdump")
            }

            // 57) Wiâ€‘Fi advanced (macOS): scan networks
            if lowered.contains("wifi scan") || lowered.contains("wi-fi scan") || lowered.contains("scan wifi") {
                return ("/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport --scan", "airport")
            }

            // 58) Network quality (macOS)
            if lowered.contains("network quality") || lowered.contains("networkquality") || lowered.contains("capacity test") {
                return ("networkQuality 2>&1 || echo 'networkQuality not found (macOS 12+); install via OS update'", "networkQuality")
            }

            // 59) SSH algorithms (client-supported)
            if lowered.contains("ssh algorithms") || lowered.contains("ssh algos") || lowered.contains("ssh kex") || lowered.contains("ssh macs") {
                if lowered.contains("kex") { return ("ssh -Q kex", "ssh") }
                if lowered.contains("mac") { return ("ssh -Q mac", "ssh") }
                if lowered.contains("cipher") || lowered.contains("ciphers") { return ("ssh -Q cipher", "ssh") }
                return ("ssh -Q cipher; echo; ssh -Q kex; echo; ssh -Q mac", "ssh")
            }

            // 60) SSH server algorithms via nmap script
            if lowered.contains("ssh server algos") || lowered.contains("ssh2 enum") {
                if let host = extractHost(l) { return ("nmap --script ssh2-enum-algos -p22 \(host)", "nmap") }
            }

            // 61) HTTP/2 HPACK details via nghttp (if installed)
            if lowered.contains("hpack") || lowered.contains("nghttp") {
                if let url = firstMatch(#"(https?://[^\s]+)"#) ?? extractHost(l) { return ("nghttp -nv \(url) 2>&1 || echo 'Install with: brew install nghttp2'", "nghttp") }
            }

            // 62) nettop snapshot (macOS)
            if lowered.contains("nettop") || lowered.contains("socket snapshot") || lowered.contains("per-process network") {
                return ("nettop -L 1 -P 2>&1 || echo 'nettop may require a TTY; showing limited snapshot'", "nettop")
            }

            // 63) DKIM multi-selector scan
            if lowered.contains("dkim scan") || lowered.contains("dkim selectors") {
                if let domain = extractHost(l) ?? firstMatch(#"\b([A-Za-z0-9_.\-]+\.[A-Za-z]{2,})\b"#) {
                    return ("for s in default s1 s2 selector1 selector2; do echo \"$s:\"; dig +short TXT $s._domainkey.\(domain); done", "dig")
                }
            }

            // 64) Certificate SANs extraction
            if lowered.contains("cert sans") || lowered.contains("certificate sans") || lowered.contains("subject alt names") {
                if let host = extractHost(l) { return ("echo | openssl s_client -connect \(host):443 -servername \(host) 2>/dev/null | openssl x509 -noout -text | awk '/Subject Alternative Name/,/X509v3/';", "openssl") }
            }

            // 65) CDN/WAF headers fingerprint
            if lowered.contains("waf headers") || lowered.contains("cdn headers") || lowered.contains("fingerprint headers") {
                if let url = firstMatch(#"(https?://[^\s]+)"#) ?? extractHost(l) { return ("curl -s -D - -o /dev/null \(url) | egrep -i '^(server:|x-powered-by:|cf-ray:|x-akamai|via:|x-cache:|x-amz-cf|x-served-by:)'", "curl") }
            }

            return nil
        }
        
        // First try to map common network intents to concrete commands
        var effectiveCommand = commandPart
        var primaryTool: String? = commandPart.split(separator: " ", maxSplits: 1, omittingEmptySubsequences: true).first.map(String.init)

        if let mapped = mapNetworkIntent(commandPart) {
            effectiveCommand = mapped.cmd
            primaryTool = mapped.tool
        } else {
            // Fallback: detect ports/services phrasing
            let lowered = commandPart.lowercased()
            let looksLikePortIntent = (
                (lowered.contains("what ports") || lowered.contains("open ports") || lowered.contains("opened ports") || lowered.contains("ports are open")) &&
                (lowered.contains("on ") || lowered.contains("for ") || lowered.contains("against "))
            ) || (
                lowered.contains("port scan") ||
                lowered.contains("scan ports") ||
                (lowered.contains("scan") && (lowered.contains("services") || lowered.contains("ports")))
            ) || (
                lowered.contains("services are exposed") || lowered.contains("what services are exposed") || lowered.contains("identify services")
            )

            func extractHost(from s: String) -> String? {
                if let re = try? NSRegularExpression(pattern: #"\b\d{1,3}(?:\.\d{1,3}){3}\b"#, options: []),
                   let m = re.firstMatch(in: s, options: [], range: NSRange(location: 0, length: s.utf16.count)),
                   let r = Range(m.range, in: s) { return String(s[r]) }
                if let re = try? NSRegularExpression(pattern: #"\b(?:on|for|against)\s+([A-Za-z0-9_.\-]+)\b"#, options: [.caseInsensitive]),
                   let m = re.firstMatch(in: s, options: [], range: NSRange(location: 0, length: s.utf16.count)),
                   m.numberOfRanges >= 2,
                   let r = Range(m.range(at: 1), in: s) { return String(s[r]) }
                return nil
            }

            if looksLikePortIntent, let host = extractHost(from: commandPart) {
                effectiveCommand = "nmap -sV -Pn \(host)"
                primaryTool = "nmap"
            }
        }

        // Build the final command with environment exports and working directory change
        let exportPrefix = envExports.map { "export \($0.0)=\(shellEscape($0.1))" }.joined(separator: " && ")
        let cdPrefix = "cd \(shellEscape(workingDirectory.path))"
        let finalCommand: String
        if exportPrefix.isEmpty {
            finalCommand = "\(cdPrefix) && \(effectiveCommand)"
        } else {
            finalCommand = "\(exportPrefix) && \(cdPrefix) && \(effectiveCommand)"
        }
        let executedCommand = finalCommand

        var installedTools: [String] = []
        var stderrAcc = ""

        // Identify primary tool availability (preferring override if set)
        let tool = primaryTool
        
        if let toolName = tool, !toolName.isEmpty {
            // Check if tool is available
            let available = await isToolAvailable(toolName, timeout: timeout)
            if !available {
                #if os(macOS)
                // Try installing with brew if available
                let brewAvailable = await isToolAvailable("brew", timeout: timeout)
                if brewAvailable {
                    let installResult = await attemptInstallWithBrew(toolName, timeout: timeout)
                    if installResult.installed {
                        installedTools.append(toolName)
                    }
                    stderrAcc += installResult.stderr
                } else {
                    stderrAcc += "Homebrew is not installed or not found in PATH; cannot install tool \(toolName).\n"
                }
                #else
                stderrAcc += "Tool \(toolName) not found and automatic installation is supported only on macOS with Homebrew.\n"
                #endif
            }
        }
        
        // Snapshot file list before execution to detect newly created ones
        let beforeFiles: Set<String> = Set(listAllFiles(in: workingDirectory).map { $0.path })
        
        // Run the original command and collect outputs
        let (stdout, stderr, exitCode) = await runAndCollect(finalCommand, timeout: timeout)
        
        // Discover newly generated files for download
        let afterFiles = listAllFiles(in: workingDirectory)
        var generatedFiles: [BashGeneratedFile] = []
        var generatedImages: [BashGeneratedImage] = []
        let newOnly = afterFiles.filter { !beforeFiles.contains($0.path) }
        for url in newOnly {
            let attrs = (try? FileManager.default.attributesOfItem(atPath: url.path)) ?? [:]
            let size = (attrs[.size] as? NSNumber)?.intValue ?? 0
            let mime = mimeTypeFor(url)
            generatedFiles.append(BashGeneratedFile(filename: url.lastPathComponent, fileURL: url, mimeType: mime, bytes: size))
            if imageExtensions.contains(url.pathExtension.lowercased()) {
                generatedImages.append(BashGeneratedImage(filename: url.lastPathComponent, fileURL: url, mimeType: mime, bytes: size))
            }
        }
        
        return BashQueryResult(
            requested: requested,
            executedCommand: executedCommand,
            stdout: stdout,
            stderr: stderrAcc + stderr,
            exitCode: exitCode,
            installedTools: installedTools,
            workingDirectory: workingDirectory,
            uploadedImages: uploadedImageAttachments,
            outputImages: generatedImages,
            outputFiles: generatedFiles
        )
    }
    
    /// Runs a command via BashRunner and collects stdout and stderr asynchronously.
    /// - Parameters:
    ///   - command: The command string to run.
    ///   - timeout: Maximum time allowed for execution.
    /// - Returns: A tuple with collected stdout, stderr, and the exit code.
    private static func runAndCollect(_ command: String, timeout: TimeInterval) async -> (stdout: String, stderr: String, code: Int32) {
        var stdoutBuilder = ""
        var stderrBuilder = ""

        // Start the run handle using the project's BashRunner API
        let handle = BashRunner.run(command: command, timeout: timeout)

        // Collect streamed chunks into stdout/stderr
        for await chunk in handle.stream {
            switch chunk.stream {
            case .stdout:
                stdoutBuilder.append(chunk.text)
            case .stderr:
                stderrBuilder.append(chunk.text)
            }
        }

        // Await the exit code once the stream has finished
        let exitCode: Int32 = await handle.exitCodeTask.value

        return (stdoutBuilder, stderrBuilder, exitCode)
    }
    
    /// Checks if a tool/command is available in the PATH by running `command -v <name>`.
    /// - Parameters:
    ///   - name: The tool or command name to check.
    ///   - timeout: Timeout for the check.
    /// - Returns: True if the command exists and returns exit code 0.
    private static func isToolAvailable(_ name: String, timeout: TimeInterval) async -> Bool {
        let checkCommand = "command -v \(name)"
        let (_, _, code) = await runAndCollect(checkCommand, timeout: timeout)
        return code == 0
    }
    
    /// Attempts to install a tool using Homebrew on macOS.
    /// - Parameters:
    ///   - name: The tool name to install.
    ///   - timeout: Timeout for the installation process.
    /// - Returns: A tuple indicating if installation succeeded, along with stdout, stderr, and exit code from `brew install`.
    private static func attemptInstallWithBrew(_ name: String, timeout: TimeInterval) async -> (installed: Bool, stdout: String, stderr: String, code: Int32) {
        let installCommand = "brew install \(name)"
        let (stdout, stderr, code) = await runAndCollect(installCommand, timeout: timeout)
        let installed = code == 0
        return (installed, stdout, stderr, code)
    }
    
    // MARK: - Image helpers
    private static var imageExtensions: Set<String> { ["png","jpg","jpeg","gif","webp","bmp","tif","tiff","heic","heif","svg"] }

    /// Recursively lists image files within a directory.
    private static func listImageFiles(in directory: URL) -> [URL] {
        guard let e = FileManager.default.enumerator(at: directory, includingPropertiesForKeys: [.isRegularFileKey], options: [.skipsHiddenFiles]) else { return [] }
        var urls: [URL] = []
        for case let url as URL in e {
            if imageExtensions.contains(url.pathExtension.lowercased()) {
                urls.append(url)
            }
        }
        return urls
    }

    /// Recursively lists all regular files within a directory.
    private static func listAllFiles(in directory: URL) -> [URL] {
        guard let e = FileManager.default.enumerator(at: directory, includingPropertiesForKeys: [.isRegularFileKey], options: [.skipsHiddenFiles]) else { return [] }
        var urls: [URL] = []
        for case let url as URL in e {
            urls.append(url)
        }
        return urls
    }

    /// Best-effort MIME type for a given file URL based on its extension.
    private static func mimeTypeFor(_ url: URL) -> String {
        switch url.pathExtension.lowercased() {
        case "png": return "image/png"
        case "jpg", "jpeg": return "image/jpeg"
        case "gif": return "image/gif"
        case "webp": return "image/webp"
        case "bmp": return "image/bmp"
        case "tif", "tiff": return "image/tiff"
        case "heic": return "image/heic"
        case "heif": return "image/heif"
        case "svg": return "image/svg+xml"
        default: return "application/octet-stream"
        }
    }
}
